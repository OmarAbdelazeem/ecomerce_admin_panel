// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'chart_choice_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$ChartChoiceStateTearOff {
  const _$ChartChoiceStateTearOff();

  Users users() {
    return const Users();
  }

  TotalIncome totalIncome() {
    return const TotalIncome();
  }

  Orders orders() {
    return const Orders();
  }

  CancelledOrders cancelledOrders() {
    return const CancelledOrders();
  }

  DeliveredOrders deliveredOrders() {
    return const DeliveredOrders();
  }

  Products products() {
    return const Products();
  }
}

/// @nodoc
const $ChartChoiceState = _$ChartChoiceStateTearOff();

/// @nodoc
mixin _$ChartChoiceState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() users,
    required TResult Function() totalIncome,
    required TResult Function() orders,
    required TResult Function() cancelledOrders,
    required TResult Function() deliveredOrders,
    required TResult Function() products,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? users,
    TResult Function()? totalIncome,
    TResult Function()? orders,
    TResult Function()? cancelledOrders,
    TResult Function()? deliveredOrders,
    TResult Function()? products,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Users value) users,
    required TResult Function(TotalIncome value) totalIncome,
    required TResult Function(Orders value) orders,
    required TResult Function(CancelledOrders value) cancelledOrders,
    required TResult Function(DeliveredOrders value) deliveredOrders,
    required TResult Function(Products value) products,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Users value)? users,
    TResult Function(TotalIncome value)? totalIncome,
    TResult Function(Orders value)? orders,
    TResult Function(CancelledOrders value)? cancelledOrders,
    TResult Function(DeliveredOrders value)? deliveredOrders,
    TResult Function(Products value)? products,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChartChoiceStateCopyWith<$Res> {
  factory $ChartChoiceStateCopyWith(
          ChartChoiceState value, $Res Function(ChartChoiceState) then) =
      _$ChartChoiceStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$ChartChoiceStateCopyWithImpl<$Res>
    implements $ChartChoiceStateCopyWith<$Res> {
  _$ChartChoiceStateCopyWithImpl(this._value, this._then);

  final ChartChoiceState _value;
  // ignore: unused_field
  final $Res Function(ChartChoiceState) _then;
}

/// @nodoc
abstract class $UsersCopyWith<$Res> {
  factory $UsersCopyWith(Users value, $Res Function(Users) then) =
      _$UsersCopyWithImpl<$Res>;
}

/// @nodoc
class _$UsersCopyWithImpl<$Res> extends _$ChartChoiceStateCopyWithImpl<$Res>
    implements $UsersCopyWith<$Res> {
  _$UsersCopyWithImpl(Users _value, $Res Function(Users) _then)
      : super(_value, (v) => _then(v as Users));

  @override
  Users get _value => super._value as Users;
}

/// @nodoc

class _$Users implements Users {
  const _$Users();

  @override
  String toString() {
    return 'ChartChoiceState.users()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Users);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() users,
    required TResult Function() totalIncome,
    required TResult Function() orders,
    required TResult Function() cancelledOrders,
    required TResult Function() deliveredOrders,
    required TResult Function() products,
  }) {
    return users();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? users,
    TResult Function()? totalIncome,
    TResult Function()? orders,
    TResult Function()? cancelledOrders,
    TResult Function()? deliveredOrders,
    TResult Function()? products,
    required TResult orElse(),
  }) {
    if (users != null) {
      return users();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Users value) users,
    required TResult Function(TotalIncome value) totalIncome,
    required TResult Function(Orders value) orders,
    required TResult Function(CancelledOrders value) cancelledOrders,
    required TResult Function(DeliveredOrders value) deliveredOrders,
    required TResult Function(Products value) products,
  }) {
    return users(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Users value)? users,
    TResult Function(TotalIncome value)? totalIncome,
    TResult Function(Orders value)? orders,
    TResult Function(CancelledOrders value)? cancelledOrders,
    TResult Function(DeliveredOrders value)? deliveredOrders,
    TResult Function(Products value)? products,
    required TResult orElse(),
  }) {
    if (users != null) {
      return users(this);
    }
    return orElse();
  }
}

abstract class Users implements ChartChoiceState {
  const factory Users() = _$Users;
}

/// @nodoc
abstract class $TotalIncomeCopyWith<$Res> {
  factory $TotalIncomeCopyWith(
          TotalIncome value, $Res Function(TotalIncome) then) =
      _$TotalIncomeCopyWithImpl<$Res>;
}

/// @nodoc
class _$TotalIncomeCopyWithImpl<$Res>
    extends _$ChartChoiceStateCopyWithImpl<$Res>
    implements $TotalIncomeCopyWith<$Res> {
  _$TotalIncomeCopyWithImpl(
      TotalIncome _value, $Res Function(TotalIncome) _then)
      : super(_value, (v) => _then(v as TotalIncome));

  @override
  TotalIncome get _value => super._value as TotalIncome;
}

/// @nodoc

class _$TotalIncome implements TotalIncome {
  const _$TotalIncome();

  @override
  String toString() {
    return 'ChartChoiceState.totalIncome()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is TotalIncome);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() users,
    required TResult Function() totalIncome,
    required TResult Function() orders,
    required TResult Function() cancelledOrders,
    required TResult Function() deliveredOrders,
    required TResult Function() products,
  }) {
    return totalIncome();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? users,
    TResult Function()? totalIncome,
    TResult Function()? orders,
    TResult Function()? cancelledOrders,
    TResult Function()? deliveredOrders,
    TResult Function()? products,
    required TResult orElse(),
  }) {
    if (totalIncome != null) {
      return totalIncome();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Users value) users,
    required TResult Function(TotalIncome value) totalIncome,
    required TResult Function(Orders value) orders,
    required TResult Function(CancelledOrders value) cancelledOrders,
    required TResult Function(DeliveredOrders value) deliveredOrders,
    required TResult Function(Products value) products,
  }) {
    return totalIncome(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Users value)? users,
    TResult Function(TotalIncome value)? totalIncome,
    TResult Function(Orders value)? orders,
    TResult Function(CancelledOrders value)? cancelledOrders,
    TResult Function(DeliveredOrders value)? deliveredOrders,
    TResult Function(Products value)? products,
    required TResult orElse(),
  }) {
    if (totalIncome != null) {
      return totalIncome(this);
    }
    return orElse();
  }
}

abstract class TotalIncome implements ChartChoiceState {
  const factory TotalIncome() = _$TotalIncome;
}

/// @nodoc
abstract class $OrdersCopyWith<$Res> {
  factory $OrdersCopyWith(Orders value, $Res Function(Orders) then) =
      _$OrdersCopyWithImpl<$Res>;
}

/// @nodoc
class _$OrdersCopyWithImpl<$Res> extends _$ChartChoiceStateCopyWithImpl<$Res>
    implements $OrdersCopyWith<$Res> {
  _$OrdersCopyWithImpl(Orders _value, $Res Function(Orders) _then)
      : super(_value, (v) => _then(v as Orders));

  @override
  Orders get _value => super._value as Orders;
}

/// @nodoc

class _$Orders implements Orders {
  const _$Orders();

  @override
  String toString() {
    return 'ChartChoiceState.orders()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Orders);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() users,
    required TResult Function() totalIncome,
    required TResult Function() orders,
    required TResult Function() cancelledOrders,
    required TResult Function() deliveredOrders,
    required TResult Function() products,
  }) {
    return orders();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? users,
    TResult Function()? totalIncome,
    TResult Function()? orders,
    TResult Function()? cancelledOrders,
    TResult Function()? deliveredOrders,
    TResult Function()? products,
    required TResult orElse(),
  }) {
    if (orders != null) {
      return orders();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Users value) users,
    required TResult Function(TotalIncome value) totalIncome,
    required TResult Function(Orders value) orders,
    required TResult Function(CancelledOrders value) cancelledOrders,
    required TResult Function(DeliveredOrders value) deliveredOrders,
    required TResult Function(Products value) products,
  }) {
    return orders(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Users value)? users,
    TResult Function(TotalIncome value)? totalIncome,
    TResult Function(Orders value)? orders,
    TResult Function(CancelledOrders value)? cancelledOrders,
    TResult Function(DeliveredOrders value)? deliveredOrders,
    TResult Function(Products value)? products,
    required TResult orElse(),
  }) {
    if (orders != null) {
      return orders(this);
    }
    return orElse();
  }
}

abstract class Orders implements ChartChoiceState {
  const factory Orders() = _$Orders;
}

/// @nodoc
abstract class $CancelledOrdersCopyWith<$Res> {
  factory $CancelledOrdersCopyWith(
          CancelledOrders value, $Res Function(CancelledOrders) then) =
      _$CancelledOrdersCopyWithImpl<$Res>;
}

/// @nodoc
class _$CancelledOrdersCopyWithImpl<$Res>
    extends _$ChartChoiceStateCopyWithImpl<$Res>
    implements $CancelledOrdersCopyWith<$Res> {
  _$CancelledOrdersCopyWithImpl(
      CancelledOrders _value, $Res Function(CancelledOrders) _then)
      : super(_value, (v) => _then(v as CancelledOrders));

  @override
  CancelledOrders get _value => super._value as CancelledOrders;
}

/// @nodoc

class _$CancelledOrders implements CancelledOrders {
  const _$CancelledOrders();

  @override
  String toString() {
    return 'ChartChoiceState.cancelledOrders()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is CancelledOrders);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() users,
    required TResult Function() totalIncome,
    required TResult Function() orders,
    required TResult Function() cancelledOrders,
    required TResult Function() deliveredOrders,
    required TResult Function() products,
  }) {
    return cancelledOrders();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? users,
    TResult Function()? totalIncome,
    TResult Function()? orders,
    TResult Function()? cancelledOrders,
    TResult Function()? deliveredOrders,
    TResult Function()? products,
    required TResult orElse(),
  }) {
    if (cancelledOrders != null) {
      return cancelledOrders();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Users value) users,
    required TResult Function(TotalIncome value) totalIncome,
    required TResult Function(Orders value) orders,
    required TResult Function(CancelledOrders value) cancelledOrders,
    required TResult Function(DeliveredOrders value) deliveredOrders,
    required TResult Function(Products value) products,
  }) {
    return cancelledOrders(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Users value)? users,
    TResult Function(TotalIncome value)? totalIncome,
    TResult Function(Orders value)? orders,
    TResult Function(CancelledOrders value)? cancelledOrders,
    TResult Function(DeliveredOrders value)? deliveredOrders,
    TResult Function(Products value)? products,
    required TResult orElse(),
  }) {
    if (cancelledOrders != null) {
      return cancelledOrders(this);
    }
    return orElse();
  }
}

abstract class CancelledOrders implements ChartChoiceState {
  const factory CancelledOrders() = _$CancelledOrders;
}

/// @nodoc
abstract class $DeliveredOrdersCopyWith<$Res> {
  factory $DeliveredOrdersCopyWith(
          DeliveredOrders value, $Res Function(DeliveredOrders) then) =
      _$DeliveredOrdersCopyWithImpl<$Res>;
}

/// @nodoc
class _$DeliveredOrdersCopyWithImpl<$Res>
    extends _$ChartChoiceStateCopyWithImpl<$Res>
    implements $DeliveredOrdersCopyWith<$Res> {
  _$DeliveredOrdersCopyWithImpl(
      DeliveredOrders _value, $Res Function(DeliveredOrders) _then)
      : super(_value, (v) => _then(v as DeliveredOrders));

  @override
  DeliveredOrders get _value => super._value as DeliveredOrders;
}

/// @nodoc

class _$DeliveredOrders implements DeliveredOrders {
  const _$DeliveredOrders();

  @override
  String toString() {
    return 'ChartChoiceState.deliveredOrders()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is DeliveredOrders);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() users,
    required TResult Function() totalIncome,
    required TResult Function() orders,
    required TResult Function() cancelledOrders,
    required TResult Function() deliveredOrders,
    required TResult Function() products,
  }) {
    return deliveredOrders();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? users,
    TResult Function()? totalIncome,
    TResult Function()? orders,
    TResult Function()? cancelledOrders,
    TResult Function()? deliveredOrders,
    TResult Function()? products,
    required TResult orElse(),
  }) {
    if (deliveredOrders != null) {
      return deliveredOrders();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Users value) users,
    required TResult Function(TotalIncome value) totalIncome,
    required TResult Function(Orders value) orders,
    required TResult Function(CancelledOrders value) cancelledOrders,
    required TResult Function(DeliveredOrders value) deliveredOrders,
    required TResult Function(Products value) products,
  }) {
    return deliveredOrders(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Users value)? users,
    TResult Function(TotalIncome value)? totalIncome,
    TResult Function(Orders value)? orders,
    TResult Function(CancelledOrders value)? cancelledOrders,
    TResult Function(DeliveredOrders value)? deliveredOrders,
    TResult Function(Products value)? products,
    required TResult orElse(),
  }) {
    if (deliveredOrders != null) {
      return deliveredOrders(this);
    }
    return orElse();
  }
}

abstract class DeliveredOrders implements ChartChoiceState {
  const factory DeliveredOrders() = _$DeliveredOrders;
}

/// @nodoc
abstract class $ProductsCopyWith<$Res> {
  factory $ProductsCopyWith(Products value, $Res Function(Products) then) =
      _$ProductsCopyWithImpl<$Res>;
}

/// @nodoc
class _$ProductsCopyWithImpl<$Res> extends _$ChartChoiceStateCopyWithImpl<$Res>
    implements $ProductsCopyWith<$Res> {
  _$ProductsCopyWithImpl(Products _value, $Res Function(Products) _then)
      : super(_value, (v) => _then(v as Products));

  @override
  Products get _value => super._value as Products;
}

/// @nodoc

class _$Products implements Products {
  const _$Products();

  @override
  String toString() {
    return 'ChartChoiceState.products()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Products);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() users,
    required TResult Function() totalIncome,
    required TResult Function() orders,
    required TResult Function() cancelledOrders,
    required TResult Function() deliveredOrders,
    required TResult Function() products,
  }) {
    return products();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? users,
    TResult Function()? totalIncome,
    TResult Function()? orders,
    TResult Function()? cancelledOrders,
    TResult Function()? deliveredOrders,
    TResult Function()? products,
    required TResult orElse(),
  }) {
    if (products != null) {
      return products();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Users value) users,
    required TResult Function(TotalIncome value) totalIncome,
    required TResult Function(Orders value) orders,
    required TResult Function(CancelledOrders value) cancelledOrders,
    required TResult Function(DeliveredOrders value) deliveredOrders,
    required TResult Function(Products value) products,
  }) {
    return products(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Users value)? users,
    TResult Function(TotalIncome value)? totalIncome,
    TResult Function(Orders value)? orders,
    TResult Function(CancelledOrders value)? cancelledOrders,
    TResult Function(DeliveredOrders value)? deliveredOrders,
    TResult Function(Products value)? products,
    required TResult orElse(),
  }) {
    if (products != null) {
      return products(this);
    }
    return orElse();
  }
}

abstract class Products implements ChartChoiceState {
  const factory Products() = _$Products;
}
